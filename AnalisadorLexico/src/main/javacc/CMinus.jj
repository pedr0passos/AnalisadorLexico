options {
    LOOKAHEAD = 2;
    UNICODE_INPUT = false; // Garante que apenas caracteres ASCII sejam aceitos
}

PARSER_BEGIN(SimpleParser)

package javacc;

import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import model.ModelToken;

public class SimpleParser {
    
    public void analisar() throws ParseException {
        this.Start();
    }

    private static final Map<Integer, String> tokenNameMap = createTokenNameMap();

    private static Map<Integer, String> createTokenNameMap() {
        Map<Integer, String> map = new HashMap<>();
        Field[] fields = SimpleParserConstants.class.getDeclaredFields();
        for (Field field : fields) {
            if (field.getType() == int.class) {
                int value = 0;
                try {
                    value = field.getInt(null); 
                } catch (IllegalArgumentException | IllegalAccessException ex) {
                    Logger.getLogger(SimpleParser.class.getName()).log(Level.SEVERE, null, ex);
                }
                map.put(value, field.getName());
            }
        }
        return map;
    }

    public ArrayList<ModelToken> getTokens(InputStream codigo) throws ParseException {
        var tokens = new ArrayList<ModelToken>();
        this.ReInit(codigo); 
        while (true) {
            Token token = this.getNextToken();
            if (token.kind == SimpleParserConstants.EOF) break;
            String tokenNome = tokenNameMap.get(token.kind);
            if (tokenNome == null) {
                tokenNome = SimpleParserConstants.tokenImage[token.kind];
            } else {
                tokenNome = "<" + tokenNome + ">";
            }
            tokens.add(new ModelToken(tokenNome, token.image));
        }
        return tokens;
    }
}

PARSER_END(SimpleParser)

///////////////////////////////////////////////////////////////////////////////
// SKIP (espaços e comentários)
///////////////////////////////////////////////////////////////////////////////
SKIP : { " " | "\t" | "\n" | "\r" }

SKIP : {
    <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ( "\n" | "\r" | "\r\n" )>
}

SKIP : {
    <MULTI_LINE_COMMENT: "/*" ( ~["*"] )* ( "*" ( ~["/"] )* )* "/">
}

///////////////////////////////////////////////////////////////////////////////
// Tokens válidos
///////////////////////////////////////////////////////////////////////////////
TOKEN : {
    < DEFINE: "#define" >
  | < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)+)? >
  // Definições auxiliares de caracteres
  | < #LETTER: ["a"-"z", "A"-"Z", "_"] >
  | < #DIGIT: ["0"-"9"] >
  | < ADD: "+" >
  | < SUB: "-" >
  | < MUL: "*" >
  | < DIV: "/" >
  | < MOD: "%" >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
  | < SEMICOLON: ";" >
  | < AUTO: "auto" >
  | < STATIC: "static" >
  | < EXTERN: "extern" >
  | < CONST: "const" >
  | < VOID: "void" >
  | < CHAR: "char" >
  | < FLOAT: "float" >
  | < DOUBLE: "double" >
  | < SIGNED: "signed" >
  | < UNSIGNED: "unsigned" >
  | < SHORT: "short" >
  | < INT: "int" >
  | < LONG: "long" >
  | < RETURN: "return" >
  | < PRINTF: "printf" >
  | < SCANF: "scanf" >
  | < BREAK: "break" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < OR: "||" >
  | < AND: "&&" >
  | < EQ: "==" >
  | < NEQ: "!=" >
  | < LT: "<" >
  | < LTE: "<=" >
  | < GT: ">" >
  | < GTE: ">=" >
  | < ASSIGN: "=" >
  | < PLUS_ASSIGN: "+=" >
  | < MINUS_ASSIGN: "-=" >
  | < MUL_ASSIGN: "*=" >
  | < DIV_ASSIGN: "/=" >
  | < MOD_ASSIGN: "%=" >
  | < COMMA: "," >
  | < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < DOT: "." >
  | < LITERAL: "\"" (~["\""])* "\"" >
  // IDENTIFIER: somente caracteres ASCII e com tamanho máximo de 31
  | < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)* >
    {
        if (matchedToken.image.length() > 31) {
            throw new TokenMgrError("Erro: Nome de variável com mais de 31 caracteres: " + matchedToken.image, TokenMgrError.LEXICAL_ERROR);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// Tokens auxiliares para fallback
///////////////////////////////////////////////////////////////////////////////
TOKEN : {
    < #ANY_CHAR: ["\u0000"-"\uFFFF"] >
}

TOKEN : {
    < INVALID: <ANY_CHAR> >
    {
        throw new TokenMgrError("Erro léxico: caractere inválido \"" + matchedToken.image + "\" encontrado.", TokenMgrError.LEXICAL_ERROR);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Produções (a gramática foi adaptada para corresponder à especificação)
///////////////////////////////////////////////////////////////////////////////

/* Início:
   <programa> → <especificador> <tipo> ID <programa2>
              | #define ID NUM <programa>   // observe que o <CRLF> é implicitamente tratado
              | ε
*/
void Start() : {} {
    Programa() <EOF>
}

void Programa() : {} {
    (
      Especificador() Tipo() <IDENTIFIER> Programa2()
    | <DEFINE> <IDENTIFIER> <NUMBER> Programa()
    | {} 
    )
}

/* <programa2> → ; <programa>
                 | [ NUM ] ; <programa>
                 | ( <listaParametros> ) <bloco> <programa>
                 | , <listaID> <programa>
*/
void Programa2() : {} {
    (
        <SEMICOLON> Programa()
      | <LBRACKET> <NUMBER> <RBRACKET> <SEMICOLON> Programa()
      | <LPAREN> ListaParametros() <RPAREN> Bloco() Programa()
      | <COMMA> ListaID() Programa()
    )
}

/* <listaID> → ID <declaracaoParam2> <listaIDTail> */
void ListaID() : {} {
    <IDENTIFIER> DeclaracaoParam2() ListaIDTail()
}

/* <listaIDTail> → ; | , <listaID> */
void ListaIDTail() : {} {
    (
      <SEMICOLON>
    | <COMMA> ListaID()
    )
}

/* <especificador> → AUTO | STATIC | EXTERN | CONST | ε */
void Especificador() : {} {
    ( <AUTO> | <STATIC> | <EXTERN> | <CONST> )?
}

/* <tipo> → VOID | CHAR | FLOAT | DOUBLE | SIGNED <inteiro> | UNSIGNED <inteiro> | <inteiro> */
void Tipo() : {} {
    (
        <VOID> | <CHAR> | <FLOAT> | <DOUBLE>
      | <SIGNED> Inteiro()
      | <UNSIGNED> Inteiro()
      | Inteiro()
    )
}

/* <inteiro> → SHORT | INT | LONG */
void Inteiro() : {} {
    ( <SHORT> | <INT> | <LONG> )
}

/* <listaParametros> → <listaParamRestante> | ε
   (aqui usamos: listaParamRestante = declaracaoParam (, declaracaoParam)* )
*/
void ListaParametros() : {} {
    ( DeclaracaoParam() ( <COMMA> DeclaracaoParam() )* )?
}

/* <declaracaoParam> → <tipo> ID <declaracaoParam2> */
void DeclaracaoParam() : {} {
    Tipo() <IDENTIFIER> DeclaracaoParam2()
}

/* <declaracaoParam2> → [ NUM ] | ε */
void DeclaracaoParam2() : {} {
    ( <LBRACKET> <NUMBER> <RBRACKET> )?
}

/* <bloco> → { <conjuntoInst> } | ; <conjuntoInst> */
void Bloco() : {} {
    (
       <LBRACE> ConjuntoInst() <RBRACE>
     | <SEMICOLON> ConjuntoInst()
    )
}

/* <conjuntoInst> → <programa> <conjuntoInst>
                    | <instrucoes> <conjuntoInst>
                    | ε
*/

void ConjuntoInstElement() : {} {
    Declaracao() | Instrucoes()
}

void ConjuntoInst() : {} {
    ( ConjuntoInstElement() )*
}

/* <instrucoes> → ID <expressao> ;
                   | RETURN <expr> ;
                   | PRINTF ( <expr> ) ;
                   | SCANF ( ID ) ;
                   | BREAK ;
                   | IF ( <expr> ) <instrucoes> <instrucoesIf>
*/
void Instrucoes() : {} {
    (
        Expr() <SEMICOLON>
      | <RETURN> Expr() <SEMICOLON>
      | <PRINTF> <LPAREN> Expr() <RPAREN> <SEMICOLON>
      | <SCANF> <LPAREN> <IDENTIFIER> <RPAREN> <SEMICOLON>
      | <BREAK> <SEMICOLON>
      | <IF> <LPAREN> Expr() <RPAREN> Instrucoes() InstrucoesIf()
      | Bloco()
      | Declaracao()
    )
}


/* <instrucoesIf> → ELSE <instrucoes> | ε */
void InstrucoesIf() : {} {
    (
       <ELSE> Instrucoes()
     | {}
    )
}

/* <expressao> → <atribuicao>
                  | [ <expr> ] <atribuicao>
                  | ( <exprList> )
                  | ε
*/
void Expressao() : {} {
    (
       Atribuicao()
     | <LBRACKET> Expr() <RBRACKET> Atribuicao()
     | <LPAREN> ExprLista() <RPAREN>
     | {}
    )
}

/* <atribuicao> → <operadorAtrib> <expr>
   (Observação: a implementação abaixo segue o estilo “C” – ou seja, uma expressão
    seguida, opcionalmente, de um operador de atribuição e outra expressão.)
*/
void Atribuicao() : {} {
    Expr() ( OperadorAtrib() Expr() )?
    {
        if ((token.kind == SimpleParserConstants.PLUS_ASSIGN ||
             token.kind == SimpleParserConstants.MINUS_ASSIGN ||
             token.kind == SimpleParserConstants.MUL_ASSIGN ||
             token.kind == SimpleParserConstants.DIV_ASSIGN ||
             token.kind == SimpleParserConstants.MOD_ASSIGN ||
             token.kind == SimpleParserConstants.ASSIGN) &&
            getToken(1).kind == SimpleParserConstants.SEMICOLON) {
            throw new ParseException("Erro: expressão esperada após o operador de atribuição.");
        }
    }
}

void OperadorAtrib() : {} {
    ( <ASSIGN> | <MUL_ASSIGN> | <DIV_ASSIGN> | <MOD_ASSIGN> | <PLUS_ASSIGN> | <MINUS_ASSIGN> )
}

/* <expr> → <exprAnd> <exprOr> */
void Expr() : {} {
    ExprOr()
}

/* <exprOr> → OR <exprAnd> <exprOr> | ε 
   (implementado com iteração: ExprAnd() ( <OR> ExprAnd() )* )
*/
void ExprOr() : {} {
    ExprAnd() ( <OR> ExprAnd() )*
}

/* <exprAnd> → <exprEqual> <exprAnd2>
   (aqui, <exprAnd2> é implementado como a repetição opcional: ( <AND> ExprEqual() )* )
*/
void ExprAnd() : {} {
    ExprEqual() ( <AND> ExprEqual() )*
}

/* <exprEqual> → <exprRelational> <exprEqual2>
   (com repetição opcional para os operadores de igualdade)
*/
void ExprEqual() : {} {
    ExprRelacional() ( ( <EQ> | <NEQ> ) ExprRelacional() )*
}

/* <exprRelational> → <exprPlus> <exprRelational2>
   (com repetição opcional para os operadores relacionais)
*/
void ExprRelacional() : {} {
    ExprAditiva() ( ( <LT> | <LTE> | <GT> | <GTE> ) ExprAditiva() )*
}

/* <exprPlus> → <exprMult> <exprPlus2> */
void ExprAditiva() : {} {
    ExprMultiplicativa() ( ( <ADD> | <SUB> ) ExprMultiplicativa() )*
}

/* <exprMult> → <exprUnary> <exprMult2> */
void ExprMultiplicativa() : {} {
    ExprUnaria() ( ( <MUL> | <DIV> | <MOD> ) ExprUnaria() )*
}

/* <exprUnary> → + <exprParenthesis> | - <exprParenthesis> | <exprParenthesis> */
void ExprUnaria() : {} {
    ( <ADD> | <SUB> )? ExprPrimaria()
}

/* <exprParenthesis> → ( <expr> ) | <primary>
   (aqui, <primary> está incorporado na produção abaixo)
*/
void ExprPrimaria() : {} {
    (
        <IDENTIFIER> ( <LBRACKET> Expr() <RBRACKET> | <LPAREN> ExprLista() <RPAREN> )?
      | <NUMBER>
      | <LITERAL>
      | <LPAREN> Expr() <RPAREN>
    )
}

/* <exprList> → <expr> <exprListTail> | ε
   (<exprListTail> é implementado pela repetição opcional de “, Expr()”)
*/
void ExprLista() : {} {
    ( Expr() ( <COMMA> Expr() )* )?
}

/* Para declarações internas (por exemplo, dentro de um bloco) usamos a mesma
   produção que no nível de programa.
*/
void Declaracao() : {} {
    Especificador() Tipo() <IDENTIFIER> Declaracao2() <SEMICOLON>
}

void Declaracao2() : {} {
    (
        
        LOOKAHEAD( <LBRACKET> | <LPAREN> )
        (
            <LBRACKET> <NUMBER> <RBRACKET>              // Array
          | <LPAREN> ListaParametros() <RPAREN> Bloco()   // Função
        )
      |
        // Caso contrário, é uma declaração de variável simples,
        // com inicialização opcional:
        ( <ASSIGN> Expr() )?
    )
}

